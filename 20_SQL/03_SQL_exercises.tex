\section{Exercises 1}
\label{sec:SQLExercises1}

Some Queries are on \href{https://docs.google.com/document/d/10g0QW-8TP935AQhp6Wcjyli3I-zSqmvAGqt1ORVYnio/edit?usp=sharing}{this google doc}.


\begin{exm} For each day display the total amount of admissions on that day. Display the amount changed from the previous date.
\begin{lstlisting}[language=SQL]
SELECT admission_date, COUNT(admission_date) AS admission_day,
 COUNT(admission_date) - 
 LAG(count(admission_date)) OVER(ORDER BY admission_date) AS admission_count_change 
FROM admissions
GROUP BY admission_date
------------------------
WITH admission_counts_table AS (
  SELECT admission_date, COUNT(patient_id) AS admission_count
  FROM admissions 
GROUP BY admission_date
ORDER BY admission_date DESC)
SELECT admission_date, admission_count, 
  admission_count - 
      LAG(admission_count) OVER(ORDER BY admission_date) AS admission_count_change 
FROM admission_counts_table
\end{lstlisting}
\end{exm}

\begin{exm} Retained customers
\begin{lstlisting}[language=SQL]
WITH t AS (SELECT date, user_id,
           LAG(date) OVER (PARTITION BY user_id ORDER BY date) AS prev_date
           FROM activity)
SELECT date,
  COUNT(DISTINCT user_id) AS active_users,
  COUNT(DISTINCT CASE
     WHEN prev_date=DATE(date, '-1 day') THEN user_id END) AS retained_u,
  COUNT(DISTINCT CASE
     WHEN prev_date = DATE(date, '-1 day') THEN user_id END) * 1.0 /
                        COUNT(DISTINCT user_id) AS retention
FROM t
GROUP BY date
ORDER BY date;
------------------------------------------------------
WITH user_activity AS 
 (SELECT date, user_id,
  LAG(date) OVER (PARTITION BY user_id ORDER BY date) AS prev_date
  FROM activity),
     daily_stats AS 
  (SELECT date, COUNT(DISTINCT user_id) AS active_users,
   COUNT(DISTINCT CASE WHEN prev_date=DATE(date, '-1 day') THEN user_id
        END) AS retained_users
    FROM user_activity
    GROUP BY date)
SELECT date, active_users, retained_users,
    retained_users * 1.0 / active_users AS retention
FROM daily_stats
ORDER BY date;
\end{lstlisting}
\end{exm}

\begin{exm} Count and show result in one row:
\begin{lstlisting}[language=SQL]
SELECT
    COUNT(CASE WHEN gender = 'M' THEN 1 END) AS male_count,
    COUNT(CASE WHEN gender = 'F' THEN 1 END) AS female_count
FROM patients;
\end{lstlisting}
\end{exm}

\begin{exm} (Medium) 
Show number of patients per city sorted by patient count and then city.
\begin{lstlisting}[language=SQL]
SELECT city, COUNT(DISTINCT patient_id) as num_patients
FROM patients
GROUP BY city
ORDER BY num_patients DESC, city ASC
\end{lstlisting}
\end{exm}

\begin{exm}  (Medium) 
Show first name, last name and role of every person that is either patient or doctor.
The roles are either ``Patient'' or ``Doctor''.
\begin{marginfigure}
\centering
\subfloat[]{\includegraphics[width=0.7\textwidth]{00_figures/SQL/patients}}\hspace{0.5cm}
\subfloat[]{\includegraphics[width=0.7\textwidth]{00_figures/SQL/doctors}}\hspace{0.5cm}
\subfloat[]{\includegraphics[width=0.5\textwidth]{00_figures/SQL/EO1}}
\caption[11\baselineskip]{Patients, doctors, and expected output.\label{fig:SQLEg1}}
\end{marginfigure}

\begin{lstlisting}[language=SQL]
SELECT first_name, last_name, 'Patient' as role 
FROM patients union all (SELECT first_name, last_name, 'Doctor' 
FROM doctors);
\end{lstlisting}
\end{exm}



\begin{exm} 
(Medium) Show all allergies ordered by popularity. 
Remove NULL values from query. See \cref{fig:SQLEg1} for \emph{patients} table.
\begin{lstlisting}[language=SQL]
SELECT allergies, COUNT(DISTINCT patient_id) AS total_diagnosis
FROM patients
GROUP BY allergies
Having allergies NOT null
ORDER BY total_diagnosis DESC
\end{lstlisting}
\end{exm}

\begin{exm} (Medium)
Show all patient's first name, last name, and birth date who were born in the 1970s decade. 
Sort the list starting from the earliest birth date.
\begin{lstlisting}[language=SQL]
SELECT first_name, last_name, birth_date
FROM patients
WHERE YEAR(birth_date) BETWEEN 1970 AND 1979
-- WHERE FLOOR(YEAR(birth_date) / 10) = 197
ORDER BY birth_date ASC;
\end{lstlisting}
\end{exm}


\begin{exm} The following make the same result:
\begin{lstlisting}[language=SQL]
SELECT patient_id, weight, height, 
  CASE  WHEN (weight / power(height/100.0, 2)) >= 30 then 1 else 0  END as isObese
FROM patients

SELECT patient_id,  weight,  height,
  weight / power(CAST(height AS float) / 100, 2) >= 30 AS obese
FROM patients

# Shortest: combined two above:
SELECT patient_id,  weight,  height,
  weight / power(height/ 100.00, 2) >= 30 AS obese
FROM patients
\end{lstlisting}
\end{exm}


\begin{exm} Difficult
\begin{lstlisting}[language=SQL]
SELECT  p.patient_id,  p.first_name,  p.last_name, 
                    ph.specialty AS attending_doctor_specialty
FROM patients p  
            JOIN admissions a ON a.patient_id = p.patient_id
            JOIN doctors ph ON ph.doctor_id = a.attending_doctor_id
WHERE ph.first_name = 'Lisa' and a.diagnosis = 'Epilepsy'
--------------
SELECT p.patient_id,  p.first_name,  p.last_name,  doc1.specialty
FROM patients p JOIN (
       SELECT *  
       FROM admissions JOIN doctors 
      ON admissions.attending_doctor_id = doctors.doctor_id ) AS
doc1 USING (patient_id)
WHERE  doc1.diagnosis = 'Epilepsy' AND doc1.first_name = 'Lisa'
--------------
SELECT p.patient_id,  p.first_name,  p.last_name,  doctors.specialty
FROM patients p,  doctors,  admissions
WHERE p.patient_id = admissions.patient_id
     AND admissions.attending_doctor_id = doctors.doctor_id
     AND admissions.diagnosis = 'Epilepsy'
     AND doctors.first_name = 'Lisa';
\end{lstlisting}
\end{exm}

\begin{exm} All patients who have gone through admissions, can see their medical documents on our site. Those patients are given a temporary password after their first admission. 
Show the patient\_id and temp\_password.

The password must be the following, in order:
\begin{enumerate}
\item patient\_id
\item the numerical length of patient's last\_name
\item year of patient's birth\_date
\end{enumerate}
\begin{marginfigure}%  [-1\baselineskip]  % Vertical offset of 1 line,
\centering
\subfloat[]{\includegraphics[width=0.7\textwidth]{00_figures/SQL/patients}}\hspace{0.5cm}
\subfloat[]{\includegraphics[width=0.7\textwidth]{00_figures/SQL/admissions}}\hspace{0.5cm}
\caption[11\baselineskip]{Patients and admissions.\label{fig:SQLEg2}}
\end{marginfigure}

\begin{lstlisting}[language=SQL]
-- This did not work: It kept putting a dot between the numbers:
SELECT patient_id, 
    CAST(CAST(patient_id AS INT) as TEXT) ||
    CAST(LEN(last_name) AS TEXT) || 
    CAST(YEAR(birth_date) AS TEXT) AS temp_password
FROM patients;

-- This is their solution: 
-- I do not know why admissions table is involved
-- 
SELECT
  DISTINCT P.patient_id,
  CONCAT( P.patient_id, LEN(last_name),
    YEAR(birth_date)
  ) AS temp_password
FROM patients P
  JOIN admissions A ON A.patient_id = P.patient_id
 
-- another solution:
SELECT DISTINCT p.patient_id,
  p.patient_id || floor(len(last_name)) || floor(YEAR(birth_date)) 
  AS temp_password
FROM patients p
  JOIN admissions a ON p.patient_id = a.patient_id 

-- and another
SELECT pa.patient_id, ad.patient_id || 
                      FLOOR(len(pa.last_name)) || 
                      FLOOR(YEAR(pa.birth_date)) AS temp_password
FROM patients pa JOIN 
admissions ad ON pa.patient_id = ad.patient_id
GROUP by pa.patient_id;
\end{lstlisting}
\end{exm}


\begin{exm} Each admission costs \$50 for patients without insurance, 
and \$10 for patients with insurance. 
All patients with an even patient\_id have insurance.

Give each patient a `Yes' if they have insurance, and a `No' if they don't have insurance. 
Add up the admission\_total cost for each has\_insurance group.
\begin{lstlisting}[language=SQL]
SELECT CASE WHEN patient_id%2=0 Then 'Yes' ELSE 'No' END AS has_insurance,
SUM(CASE WHEN patient_id%2=0 Then 10 ELSE 50 END) as cost_after_insurance
FROM admissions 
GROUP BY has_insurance;

-- another way
SELECT has_insurance, 
      CASE WHEN has_insurance='Yes' THEN COUNT(has_insurance) * 10
           ELSE count(has_insurance)*50 END AS cost_after_insurance
FROM (SELECT CASE WHEN patient_id % 2 = 0 THEN 'Yes' ELSE 'No' END 
                                                AS has_insurance  
              FROM admissions)
GROUP BY has_insurance

-- another way
SELECT has_insurance, sum(admission_cost) as admission_total
FROM (SELECT patient_id,
   CASE WHEN patient_id%2=0 THEN 'Yes' ELSE 'No' END AS has_insurance,
   CASE WHEN patient_id%2=0 THEN 10 ELSE 50 END AS admission_cost
   FROM admissions)
group by has_insurance

\end{lstlisting}
\end{exm}

\newpage
\begin{exm} Show the provinces that has more patients identified as `M' than `F'. 
Must only show full province\_name.
\begin{marginfigure}
\centering
\includegraphics[width=\textwidth]{00_figures/SQL/patients_DB1}
\caption[11\baselineskip]{Patients DB1.\label{fig:patients_DB1}}
\end{marginfigure}
\begin{lstlisting}[language=SQL]
SELECT province_name
FROM (SELECT patients.gender, 
             COUNT(patients.gender) AS gender_count, 
             patients.province_id, 
             province_names.province_name
        FROM patients JOIN province_names USING (province_id)
        GROUP BY patients.gender, patients.province_id) AS 
                                                     gender_counts
GROUP BY province_id, province_name
HAVING 
    SUM(CASE WHEN gender = 'M' THEN gender_count ELSE 0 END) > 
    SUM(CASE WHEN gender = 'F' THEN gender_count ELSE 0 END);
    
-- another way
SELECT province_name
FROM (SELECT province_name, SUM(gender = 'M') AS n_male,
                            SUM(gender = 'F') AS n_female
      FROM patients pa
      JOIN province_names pr ON pa.province_id = pr.province_id
      GROUP BY province_name)
WHERE n_male > n_female

-- another way
SELECT pr.province_name
FROM province_names AS pr JOIN patients AS pa
                       ON pa.province_id = pr.province_id
GROUP BY pr.province_name
HAVING SUM(gender = 'M') > SUM(gender = 'F');

-- another way. I like this best.
SELECT province_name 
FROM province_names
WHERE province_id IN (SELECT province_id
                      FROM patients
                      GROUP BY province_id 
                      HAVING SUM(gender = 'M') > SUM(gender = 'F'))
\end{lstlisting}
\end{exm}

\begin{exm} We need a breakdown for the total amount of admissions each doctor has started each year. Show the doctor\_id, doctor\_full\_name, specialty, year, total\_admissions for that year.
\begin{lstlisting}[language=SQL]
WITH super_table AS (SELECT *
                     FROM admissions JOIN doctors 
         ON admissions.attending_doctor_id = doctors.doctor_id)
SELECT doctor_id, first_name || ' ' || last_name AS doctor_name,
       specialty,
       count(patient_id) AS total_admissons,
       YEAR (admission_date) AS selected_year
FROM super_table
GROUP BY selected_year, doctor_name

---
SELECT has_insurance, sum(cost) as cost_after_insurance
FROM (
SELECT patient_id,
CASE WHEN patient_id%2=0 THEN 'Yes' ELSE 'No' END AS has_insurance,
CASE WHEN patient_id%2=0 THEN 10 ELSE 50 END AS cost
FROM admissions)
GROUP BY has_insurance

\end{lstlisting}
\end{exm}

\begin{exm} Sort the province names in ascending order in such a way that the province `Ontario' is always on top.
\begin{lstlisting}[language=SQL]
SELECT province_name
FROM province_names
ORDER BY
  (CASE WHEN province_name = 'Ontario' THEN 0 ELSE 1 END),
  province_name
----------------------------------------
SELECT province_name
FROM province_names
ORDER BY  province_name = 'Ontario' DESC, province_name
----------------------------------------
SELECT province_name
FROM province_names
ORDER BY CASE WHEN province_name = 'Ontario' THEN 1 ELSE 
                                province_name END
\end{lstlisting}
\end{exm}



\section{Exercises 2}
\label{sec:SQLExercises2}
These questions are from \href{https://platform.stratascratch.com}{https://platform.stratascratch.com}
and might be harder than the questions in~\Cref{sec:SQLExercises1}.
The free version has limited number of questions available (you can see and run them, just cannot check your solution or see Expected Output!!!), but this \href{https://github.com/TeslaNik/stratascratch-SQL}{GitHub repo} has a list of questions in it which hopefully is more than free version.
I have not checked at the time of writing this (Feb, 05, 2026). 
This platform does not have SQLite. I am using MySQL.

\begin{rem} 
First difference between SQLite and MySQL I had:
\begin{itemize}
\item SQLite: \code{prev\_date = DATE(date, '-1 day')}
\item MySQL: \code{prev\_date = DATE\_SUB(date, INTERVAL 1 DAY)}
\end{itemize}
\end{rem} 

\begin{marginfigure}% [-1\baselineskip]  % Vertical offset of 1 line,
  \centering
  %\captionsetup{justification=centering}
  \includegraphics[width=2\textwidth]{00_figures/SQL/SQL_Logic}
  \caption{SQL order of execution of commands}
  \label{fig:SQL_LogicMargin}
\end{marginfigure}

\begin{exm} (Question ID 9915: Highest Cost Orders) \marginnote{This ID is from stratascratch.com} Find the customers with the highest daily total order cost between 2019-02-01 and 2019-05-01. If a customer had more than one order on a certain day, sum the order costs on a daily basis. Output each customer's first name, total cost of their items, and the date. If multiple customers tie for the highest daily total on the same date, return all of them.

For simplicity, you can assume that every first name in the dataset is unique.

{\bf \color{red} Recall} the order of execution of statements in SQL~\cref{fig:SQL_LogicMargin}.
That means Window functions are evaluated after \code{WHERE}, so \code{max\_cost} doesn't exist yet when \code{WHERE} runs.
\begin{lstlisting}[language=SQL]
--- This will not work due to above remark.
WITH t as (SELECT customers.id, customers.first_name, 
                          orders.order_date, 
           SUM(orders.total_order_cost) as cust_spent_day
           FROM customers join orders on customers.id = orders.cust_id
           WHERE orders.order_date BETWEEN '2019-02-01' AND '2019-05-01'
           GROUP BY customers.id, customers.first_name, orders.order_date
           )
SELECT id, first_name, order_date, cust_spent_day,
MAX(cust_spent_day) over (partition by order_date)  as max_cost
from t
ORDER BY order_date, id
WHERE cust_spent_day = max_cost
\end{lstlisting}

\begin{lstlisting}[language=SQL]
-- This solution might not be optimal or readable or whatever
-- It shows what we could to to use the result of partition:
WITH daily_totals AS (SELECT c.id, c.first_name, o.order_date,
                      SUM(o.total_order_cost) AS cust_spent_day
                      FROM customers c
                     JOIN orders o ON c.id = o.cust_id
             WHERE o.order_date BETWEEN '2019-02-01' AND '2019-05-01'
                    GROUP BY c.id, c.first_name, o.order_date),
with_max AS (SELECT *,
      MAX(cust_spent_day) OVER (PARTITION BY order_date) AS max_cost
      FROM daily_totals)
SELECT first_name, order_date, max_cost
FROM with_max
WHERE cust_spent_day = max_cost
ORDER BY order_date, id;
\end{lstlisting}

\begin{lstlisting}[language=SQL]
-- Solution 2: no partition
WITH daily_totals AS (SELECT c.first_name, o.order_date,
                     SUM(o.total_order_cost) AS total_cost
              FROM customers c JOIN orders o ON c.id = o.cust_id
              WHERE o.order_date BETWEEN '2019-02-01' AND '2019-05-01'
                     GROUP BY c.first_name, o.order_date
                     )
SELECT *
FROM daily_totals dt
WHERE total_cost = (SELECT MAX(total_cost)
                    FROM daily_totals
                    WHERE order_date = dt.order_date)
ORDER BY order_date, first_name;
\end{lstlisting}
\end{exm}



\begin{exm}  ({\bf  \color{red}{ID 2054: Consecutive Days - Hard}})
Find all the users who were active for 3 consecutive days or more.

\begin{lstlisting}[language=SQL]
with t as (SELECT *,
   LAG(record_date, 1) OVER (PARTITION BY user_id ORDER BY record_date) AS one_dayAgo,
   LAG(record_date, 2) OVER (PARTITION BY user_id ORDER BY record_date) AS two_dayAgo
FROM sf_events),
retained_3days as (select DISTINCT user_id,
       CASE WHEN one_dayAgo = DATE_SUB(record_date, INTERVAL 1 DAY) THEN 1 ELSE 0 END AS retained_1day,
       CASE WHEN two_dayAgo = DATE_SUB(record_date, INTERVAL 2 DAY) THEN 1 ELSE 0 END AS retained_2day
       from t
HAVING (retained_2day=1) and (retained_1day=1))
select distinct user_id
from retained_3days

\end{lstlisting}
\end{exm}


\begin{exm} ({\bf ID 10318: New Products})
Calculate the net change in the number of products launched by companies in 2020 compared to 2019. Your output should include the company names and the net difference.

(Net difference = Number of products launched in 2020 - The number launched in 2019.)
\begin{lstlisting}[language=SQL]
-- My first Silution:
with tbl_2020 as (SELECT  company_name, year, COUNT(DISTINCT product_name) as prod_2020
                  FROM car_launches
                  WHERE year=2020
                  GROUP BY company_name, year),
     tbl_2019 as (SELECT  company_name, year, COUNT(DISTINCT product_name)  as prod_2019
                  FROM car_launches
                  WHERE year=2019
                  GROUP BY company_name, year)
SELECT tbl_2020.company_name, tbl_2020.prod_2020 - tbl_2019.prod_2019 as total_launch
FROM tbl_2020 join tbl_2019 USING(company_name)

-- Shorter: 
SELECT 
    company_name,
    COUNT(DISTINCT CASE WHEN year = 2020 THEN product_name END) -
    COUNT(DISTINCT CASE WHEN year = 2019 THEN product_name END) AS total_launch
FROM car_launches
WHERE year IN (2019, 2020)
GROUP BY company_name;

-- Bug Free(?): 
SELECT 
    company_name,
    COALESCE(COUNT(DISTINCT CASE WHEN year = 2020 THEN product_name END),0) -
    COALESCE(COUNT(DISTINCT CASE WHEN year = 2019 THEN product_name END),0) AS total_launch
FROM car_launches
WHERE year IN (2019, 2020)
GROUP BY company_name;
\end{lstlisting}
\end{exm}

\begin{tcolorbox}[colback=aliceblue!10!white,colframe=blue!70!black,title=\textbf{Remark}]
% olback=green!10!white,colframe=green!80!black
\code{COALESCE} is a very handy SQL function that returns the first non-NULL value in its list of arguments:

\code{COALESCE(value1, value2, value3, \dots)}


\begin{lstlisting}[language=SQL]
SELECT name, COALESCE(middle_name, `N/A`) AS middle
FROM people;
\end{lstlisting}

So, in the example above:

If a company has no launches in 2020, \code{COUNT(DISTINCT \dots)} could be 
\vari{NULL} (depends on SQL dialect).
\code{COALESCE(\dots, 0)} ensures the result is 0 instead of \vari{NULL} , so subtraction works safely.
\end{tcolorbox}



\begin{exm} ({\bf ID 515: City With the Biggest Growth and Drop})
Find which cities recorded the largest growth and biggest drop in order amount between between March 11, 2019, and April 11, 2019.
Just compare the total order amount on March 11 and April 11, 2019 for each city. Your output should include the names of the cities and the corresponding amount of growth or drop.
\begin{lstlisting}[language=SQL]
-- My First Solution:
with growth_table as (SELECT city_id,
      SUM(CASE WHEN DATE(order_timestamp_utc)='2019-04-11' THEN amount ELSE 0 END) - 
       SUM(CASE WHEN DATE(order_timestamp_utc)='2019-03-11' THEN amount ELSE 0 END) as growth
FROM postmates_orders
GROUP BY city_id)
Select city_id, growth
FROM growth_table
where growth = (SELECT MAX(growth)
                FROM growth_table) OR 
      growth = (SELECT MIN(growth)
                FROM growth_table)

\end{lstlisting}
\end{exm}



\begin{exm} Hi
\begin{lstlisting}[language=SQL]
\end{lstlisting}
\end{exm}
