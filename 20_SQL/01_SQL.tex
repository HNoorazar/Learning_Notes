Structured Query Language. Relational database.\marginnote{SQL from Coursera: UC Davis. SQLite here.}
Read. Write. Update. (no copy. no creation.)

\begin{deff}[Primary Key]
A Primary Key is a column (or a set of columns) whose values identify each row uniquely.
\end{deff}

\begin{deff}[Foreign Key]
One or more columns that can be used to identify
single row in {\bf another} table.
\end{deff}

This is how columns of a given table are selected:\marginnote{you can test these by visiting and practicing on \href{https://www.sql-practice.com}{https://www.sql-practice.com}}
\begin{lstlisting}[language=SQL]
SELECT col1, col2
FROM table_name
\end{lstlisting}

A start (*) is a \emph{wild card}; in the following all columns of table
are selected
\begin{lstlisting}[language=SQL]
SELECT *
FROM table_name
\end{lstlisting}

If you want to check out how a table looks like
by looking at a few of its rows, similar to \texttt{.head(3)} in Python, you 
can use \texttt{LIMIT}. 
 \texttt{LIMIT} is used in SQLite, Oracle uses  \texttt{where rownum<=5}
 or DB2 uses  \texttt{FETCH FIRST 10 ROWS ONLY}
\begin{lstlisting}[language=SQL]
SELECT *
FROM table_name
LIMIT #_of_records
\end{lstlisting}

You can comment out text by sandwiching it between /* and */ or a single line
can be commented out using a couple of dashes.
A table can be created by \texttt{CREATE TABLE}, but you may need
to have admin privileges. An example is given below as well as how you can
inset a record into a table:

\begin{lstlisting}[language=SQL]
CREATE TABLE shoes
(ID CHAR(10) PRIMARY KEY,
Brand CHAR(10) NOT NULL,
Price decimal(8,2) ,
Description VARCHAR(750) NULL,
)
-- Insert
INSERT INTO Shoes
VALUES('1234', 'Gucci', ...)

-- Insert even better:
INSERT INTO Shoes
(ID, Brand, ...)
VALUES('1234', 'Gucci', ...)

\end{lstlisting}
\texttt{NULL} above lets the column Description to have null values (which is different from empty string).
\texttt{VARCHAR} defines strings of variable size; if you define \texttt{VARCHAR(10)}, it will not waste
space if the string is shorter than 10 characters.

You can create temporary tables using 
\begin{lstlisting}[language=SQL]
CREATE TEMPORARY TABLE sandals AS (
SELECT * 
FROM Shoes
WHERE shoe_type = 'sandal')
\end{lstlisting}

Common Table Expression (CTE) is created as follows which has
differences with a temporary table. In the examples that will come up later
you will see how CTE can be used. Google what are their similarities and
differences.
\begin{lstlisting}[language=SQL]
WITH sandals AS(
SELECT * 
FROM Shoes
WHERE shoe_type = 'sandal'
)
\end{lstlisting}

\vspace{.5in}
\noindent {\bf \color{red}Filtering} You already see how \texttt{WHERE} is 
used to filter rows:
\begin{lstlisting}[language=SQL]
SELECT col1, col2
FROM table
WHERE col_name OPERATOR value
\*
OPERATOR can be =, >, >=, <, <=, BETWEEN, IS NULL,
<> (The symbol to the left is not-equal)
*\
SELECT product_name, supplierID
FROM products
WHERE ProductName='Tofu' AND unitPrice>5
--
... WHERE unitPrice BETWEEN 10 AND 20
--
... WHERE productNAME <> 'Alice Mutton'
--
... WHERE productName IS NULL
--
... WHERE productName IN ('Nike', 'Adidas')
\end{lstlisting}

\noindent {\bf \color{red}Filter with OR}  If there is an \texttt{OR} statement in filtering, 
then if the first condition is met, then, the second will not be evaluated;
\texttt{productName = 'Tofu' OR 'Kombu'}: Kombu will be ignored. 

\texttt{IN} is faster than \texttt{OR}.
My notes says \texttt{AND} is processed before \texttt{OR} but it seems it has
no memory, forgets \texttt{AND} and moves on to \texttt{OR}!
Parentheses is processed before \texttt{AND}:
\texttt{WHERE (suppplierID = 9 or SupplierID = 1) AND unitPrice=10} \\

\noindent The following are identical
\begin{lstlisting}[language=SQL]
SELECT * 
FROM products
where product_name <> 'Chai' AND product_name <> 'Chand'
--
SELECT * 
FROM products
where NOT product_name = 'Chai' AND NOT product_name = 'Chand'
\end{lstlisting}

\begin{table}[h!]
\centering
\begin{tabular}{c l p{8cm}}
\hline
\textbf{Step} & \textbf{Clause} & \textbf{Purpose} \\
\hline
1 & \texttt{FROM} & Identify and combine tables (including joins and subqueries). \\
2 & \texttt{WHERE} & Filter rows \emph{before} grouping. \\
3 & \texttt{GROUP BY} & Group remaining rows by specified columns. \\
4 & \texttt{HAVING} & Filter groups \emph{after} grouping. \\
5 & \texttt{SELECT} & Compute expressions and aggregates (such as \texttt{AVG}) for each group. \\
6 & \texttt{ORDER BY} & Sort the final results. \\
\hline
\end{tabular}
\caption{Logical order of SQL query processing}
\end{table}


